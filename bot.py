# -*- coding: utf-8 -*-
"""bot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wvI2_x3lhKo8x4Mh3tzTQquR219yzIU_
"""

import yfinance as yf
import pandas as pd
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.linear_model import Ridge
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, Dropout
from sklearn.metrics import mean_squared_error, mean_absolute_percentage_error
from statsmodels.tsa.arima.model import ARIMA
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from math import sqrt
import logging
import csv
import os
from dotenv import load_dotenv
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')
load_dotenv()

# --- Конфигурация ---
class Config:
    # Загрузка токена
    BOT_TOKEN = os.getenv('BOT_TOKEN')

    # Параметры данных
    N_LAGS = 30
    FORECAST_DAYS = 30
    TEST_SIZE = 0.2

    # Параметры моделей
    RIDGE_ALPHA = 0.5
    LSTM_EPOCHS = 50
    LSTM_BATCH_SIZE = 32
    LSTM_UNITS = 100

    # Параметры прогнозирования
    RECOMMENDATION_WINDOW = 5
    MIN_PRICE_CHANGE_PCT = 2.0

    # Пути
    LOG_DIR = 'logs'
    PLOT_DIR = 'plots'

# Создаем директории
for directory in [Config.LOG_DIR, Config.PLOT_DIR]:
    if not os.path.exists(directory):
        os.makedirs(directory)

if not os.path.exists('logs.txt'):
    with open('logs.txt', 'w', encoding='utf-8') as f:
        f.write('')

# --- Настройка логирования ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.join(Config.LOG_DIR, 'bot.log')),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# --- Cистема прогнозирования ---
class StockForecaster:
    """Класс для прогнозирования цен акций"""

    def __init__(self, n_lags=Config.N_LAGS):
        self.n_lags = n_lags
        self.scaler_X = MinMaxScaler(feature_range=(0, 1))
        self.scaler_y = MinMaxScaler(feature_range=(0, 1))

    def prepare_data(self, ticker, period="2y"):
        """Подготавливает данные для обучения"""
        try:
            # Загрузка данных
            stock = yf.Ticker(ticker)
            data = stock.history(period=period, interval="1d")

            if data.empty or len(data) < 100:
                raise ValueError(f"Недостаточно данных для {ticker}")

            # Используем только цену закрытия
            prices = data['Close'].values.reshape(-1, 1)

            # Масштабирование цен
            prices_scaled = self.scaler_y.fit_transform(prices)

            # Создание последовательностей
            X, y = [], []
            for i in range(self.n_lags, len(prices_scaled)):
                X.append(prices_scaled[i-self.n_lags:i, 0])
                y.append(prices_scaled[i, 0])

            X, y = np.array(X), np.array(y)

            # Разделение на train/test
            split_idx = int(len(X) * (1 - Config.TEST_SIZE))

            X_train, X_test = X[:split_idx], X[split_idx:]
            y_train, y_test = y[:split_idx], y[split_idx:]

            # Для LSTM нужно reshape
            X_train_lstm = X_train.reshape((X_train.shape[0], X_train.shape[1], 1))
            X_test_lstm = X_test.reshape((X_test.shape[0], X_test.shape[1], 1))

            # Для ARIMA - оригинальные данные
            arima_train = prices[:split_idx].flatten()
            arima_test = prices[split_idx:].flatten()

            return {
                'X_train': X_train,
                'X_test': X_test,
                'X_train_lstm': X_train_lstm,
                'X_test_lstm': X_test_lstm,
                'y_train': y_train,
                'y_test': y_test,
                'arima_train': arima_train,
                'arima_test': arima_test,
                'original_prices': prices.flatten(),
                'dates': data.index,
                'last_sequence': prices_scaled[-self.n_lags:].flatten()
            }

        except Exception as e:
            logger.error(f"Ошибка подготовки данных: {str(e)}")
            raise

    def train_models(self, data):
        """Обучает все модели"""
        models = {}

        # 1. Ridge Regression
        ridge_model = Ridge(alpha=Config.RIDGE_ALPHA, random_state=42)
        ridge_model.fit(data['X_train'], data['y_train'])
        models['ridge'] = ridge_model

        # 2. ARIMA
        arima_model = ARIMA(data['arima_train'], order=(2,1,2))
        models['arima'] = arima_model.fit()

        # 3. LSTM
        lstm_model = Sequential([
            LSTM(Config.LSTM_UNITS, return_sequences=True,
                 input_shape=(data['X_train_lstm'].shape[1], 1)),
            Dropout(0.2),
            LSTM(Config.LSTM_UNITS, return_sequences=False),
            Dropout(0.2),
            Dense(25),
            Dense(1)
        ])

        lstm_model.compile(optimizer='adam', loss='mean_squared_error')
        lstm_model.fit(
            data['X_train_lstm'],
            data['y_train'],
            epochs=Config.LSTM_EPOCHS,
            batch_size=Config.LSTM_BATCH_SIZE,
            verbose=0
        )
        models['lstm'] = lstm_model

        return models

    def evaluate_models(self, models, data):
        """Оценивает модели и выбирает лучшую"""
        results = {}

        #Оценка Ridge
        y_pred_ridge_scaled = models['ridge'].predict(data['X_test'])
        y_pred_ridge = self.scaler_y.inverse_transform(
            y_pred_ridge_scaled.reshape(-1, 1)
        ).flatten()
        y_test_original = self.scaler_y.inverse_transform(
            data['y_test'].reshape(-1, 1)
        ).flatten()

        rmse_ridge = sqrt(mean_squared_error(y_test_original, y_pred_ridge))
        mape_ridge = mean_absolute_percentage_error(y_test_original, y_pred_ridge) * 100
        results['ridge'] = {'RMSE': rmse_ridge, 'MAPE': mape_ridge}

        #Оценка ARIMA
        arima_forecast = models['arima'].forecast(steps=len(data['arima_test']))
        rmse_arima = sqrt(mean_squared_error(data['arima_test'], arima_forecast))
        mape_arima = mean_absolute_percentage_error(data['arima_test'], arima_forecast) * 100
        results['arima'] = {'RMSE': rmse_arima, 'MAPE': mape_arima}

        #Оценка LSTM
        y_pred_lstm_scaled = models['lstm'].predict(data['X_test_lstm'], verbose=0).flatten()
        y_pred_lstm = self.scaler_y.inverse_transform(
            y_pred_lstm_scaled.reshape(-1, 1)
        ).flatten()

        rmse_lstm = sqrt(mean_squared_error(y_test_original, y_pred_lstm))
        mape_lstm = mean_absolute_percentage_error(y_test_original, y_pred_lstm) * 100
        results['lstm'] = {'RMSE': rmse_lstm, 'MAPE': mape_lstm}

        # Выбор лучшей модели по RMSE
        best_model = min(results.items(), key=lambda x: x[1]['RMSE'])[0]

        return best_model, results

    def make_forecast(self, model_name, models, last_sequence, forecast_days=30):
        """Создает прогноз на будущие дни"""
        forecasts = []
        current_sequence = last_sequence.copy()

        for _ in range(forecast_days):
            if model_name == 'ridge':
                # Ridge предсказание
                prediction_scaled = models['ridge'].predict(
                    current_sequence.reshape(1, -1)
                )[0]

            elif model_name == 'lstm':
                # LSTM предсказание
                lstm_input = current_sequence.reshape(1, self.n_lags, 1)
                prediction_scaled = models['lstm'].predict(lstm_input, verbose=0)[0][0]

            elif model_name == 'arima':
                prediction = models['arima'].forecast(steps=1)[0]
                # Преобразуем в масштабированный вид для согласованности
                prediction_scaled = self.scaler_y.transform([[prediction]])[0][0]

            else:
                raise ValueError(f"Неизвестная модель: {model_name}")

            # Преобразуем обратно в исходный масштаб
            prediction_original = self.scaler_y.inverse_transform(
                [[prediction_scaled]]
            )[0][0]

            forecasts.append(prediction_original)

            # Обновляем последовательность для следующего предсказания
            current_sequence = np.roll(current_sequence, -1)
            current_sequence[-1] = prediction_scaled

        # Создаем даты для прогноза
        last_date = datetime.now()
        forecast_dates = pd.date_range(
            start=last_date + timedelta(days=1),
            periods=forecast_days,
            freq='B'
        )

        return pd.Series(forecasts, index=forecast_dates, name='Forecast')

# --- Класс для рекомендаций ---
class InvestmentAdvisor:
    """Генерирует инвестиционные рекомендации"""

    @staticmethod
    def find_trading_signals(prices, window=5):
        """Находит сигналы для покупки и продажи"""
        signals = []

        for i in range(window, len(prices) - window):
            current_price = prices.iloc[i]

            # Определяем локальные экстремумы
            local_min = min(prices.iloc[i-window:i+window+1])
            local_max = max(prices.iloc[i-window:i+window+1])

            # Проверяем, является ли текущая точка минимумом
            if current_price == local_min and current_price < prices.iloc[i-1]:
                signals.append({
                    'date': prices.index[i],
                    'price': current_price,
                    'action': 'BUY',
                    'confidence': 'high' if current_price < prices.iloc[i-1] * 0.98 else 'medium'
                })

            # Проверяем, является ли текущая точка максимумом
            elif current_price == local_max and current_price > prices.iloc[i-1]:
                signals.append({
                    'date': prices.index[i],
                    'price': current_price,
                    'action': 'SELL',
                    'confidence': 'high' if current_price > prices.iloc[i-1] * 1.02 else 'medium'
                })

        return signals

    @staticmethod
    def calculate_profit_strategy(investment, forecast_series, signals):
        """Рассчитывает потенциальную прибыль по стратегии"""
        if len(signals) < 2:
            return "Недостаточно сигналов для формирования стратегии"

        # Фильтруем сигналы
        buy_signals = [s for s in signals if s['action'] == 'BUY']
        sell_signals = [s for s in signals if s['action'] == 'SELL']

        if not buy_signals or not sell_signals:
            return "Отсутствуют как сигналы покупки, так и продажи"

        # Выбираем лучшие точки входа и выхода
        best_buy = min(buy_signals, key=lambda x: x['price'])
        best_sell = max(sell_signals, key=lambda x: x['price'])

        # Убеждаемся, что продажа идет после покупки
        if best_sell['date'] <= best_buy['date']:
            # Ищем следующую продажу после покупки
            future_sells = [s for s in sell_signals if s['date'] > best_buy['date']]
            if future_sells:
                best_sell = min(future_sells, key=lambda x: x['date'])
            else:
                return "Нет подходящей точки продажи после покупки"

        # Расчет прибыли
        shares = investment // best_buy['price']
        if shares == 0:
            return f"Недостаточно средств для покупки. Минимально: ${best_buy['price']:.2f}"

        total_cost = shares * best_buy['price']
        total_revenue = shares * best_sell['price']
        profit = total_revenue - total_cost
        profit_pct = (profit / total_cost) * 100

        # Формируем отчет
        report = f"""
 **СТРАТЕГИЯ ТОРГОВЛИ**

 **Лучшая точка входа:**
   Дата: {best_buy['date'].strftime('%d.%m.%Y')}
   Цена: ${best_buy['price']:.2f}
   Действие: ПОКУПАТЬ ({best_buy['confidence']} уверенность)

 **Лучшая точка выхода:**
   Дата: {best_sell['date'].strftime('%d.%m.%Y')}
   Цена: ${best_sell['price']:.2f}
   Действие: ПРОДАВАТЬ ({best_sell['confidence']} уверенность)

 **РАСЧЕТ ПРИБЫЛИ:**
   Инвестировано: ${investment:,.2f}
   Куплено акций: {shares:,}
   Общая стоимость покупки: ${total_cost:,.2f}
   Общий доход от продажи: ${total_revenue:,.2f}
   ПРИБЫЛЬ: ${profit:,.2f} ({profit_pct:.2f}%)

 **ПОТЕНЦИАЛЬНЫЙ РОСТ:**
   От {best_buy['date'].strftime('%d.%m')} до {best_sell['date'].strftime('%d.%m')}
   Рост цена: {((best_sell['price'] - best_buy['price']) / best_buy['price'] * 100):.2f}%
"""

        return report
        # Функция логирования
def log_user_request(user_id, ticker, investment, best_model, metric_rmse, profit_pct):
    """Записывает запрос пользователя в logs.txt"""
    log_entry = {
        'user_id': user_id,
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'ticker': ticker,
        'investment': investment,
        'best_model': best_model,
        'rmse': f"{metric_rmse:.2f}",
        'profit_pct': f"{profit_pct:.2f}%"
    }

    file_exists = os.path.isfile('logs.txt')
    with open('logs.txt', 'a', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=log_entry.keys())
        if not file_exists:
            writer.writeheader()
        writer.writerow(log_entry)

# --- Визуализация ---
def plot_forecast(historical_dates, historical_prices, forecast_dates, forecast_prices, ticker):
    """Создает график прогноза"""
    plt.figure(figsize=(14, 7))

    # Исторические данные
    plt.plot(historical_dates, historical_prices,
             label='Исторические цены', color='blue', alpha=0.7, linewidth=2)

    # Прогноз
    plt.plot(forecast_dates, forecast_prices,
             label='Прогноз (30 дней)', color='red', linestyle='--', linewidth=2)

    # Текущая цена
    current_price = historical_prices[-1]
    plt.axhline(y=current_price, color='green', linestyle=':',
                alpha=0.5, label=f'Текущая цена: ${current_price:.2f}')

    plt.title(f'Прогноз цен акций {ticker}', fontsize=16, fontweight='bold')
    plt.xlabel('Дата')
    plt.ylabel('Цена ($)')
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.xticks(rotation=45)
    plt.tight_layout()

    # Сохранение графика
    filename = f"{Config.PLOT_DIR}/forecast_{ticker}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
    plt.savefig(filename, dpi=150, bbox_inches='tight')
    plt.close()

    return filename

# --- Основная функция анализа ---
def analyze_stock(ticker, investment_amount=1000):
    """Основная функция для анализа акций"""
    try:
        logger.info(f"Начинаем анализ акций {ticker} с инвестициями ${investment_amount:,}")

        # Инициализация прогнозировщика
        forecaster = StockForecaster(n_lags=Config.N_LAGS)

        # Подготовка данных
        logger.info("Загрузка и подготовка данных...")
        data = forecaster.prepare_data(ticker)

        # Обучение моделей
        logger.info("Обучение моделей...")
        models = forecaster.train_models(data)

        # Оценка моделей
        logger.info("Оценка моделей...")
        best_model, metrics = forecaster.evaluate_models(models, data)

        # Прогнозирование
        logger.info(f"Прогнозирование с помощью {best_model.upper()}...")
        forecast = forecaster.make_forecast(
            best_model,
            models,
            data['last_sequence'],
            forecast_days=Config.FORECAST_DAYS
        )

        # Визуализация
        logger.info("Создание графика...")
        historical_dates = data['dates'][-100:]  # Последние 100 дней
        historical_prices = data['original_prices'][-100:]

        plot_filename = plot_forecast(
            historical_dates,
            historical_prices,
            forecast.index,
            forecast.values,
            ticker
        )

        # Расчет изменений
        current_price = historical_prices[-1]
        forecast_end_price = forecast.iloc[-1]
        price_change = forecast_end_price - current_price
        pct_change = (price_change / current_price) * 100

        # Генерация рекомендаций
        logger.info("Формирование рекомендаций...")
        advisor = InvestmentAdvisor()
        all_prices = pd.concat([
            pd.Series(historical_prices[-30:], index=historical_dates[-30:]),
            forecast
        ])

        signals = advisor.find_trading_signals(all_prices, window=Config.RECOMMENDATION_WINDOW)
        profit_report = advisor.calculate_profit_strategy(investment_amount, all_prices, signals)

        # Формирование отчета
        report = f"""
 **АНАЛИЗ АКЦИЙ {ticker}**

 **ЛУЧШАЯ МОДЕЛЬ:** {best_model.upper()}
 **ТОЧНОСТЬ МОДЕЛИ:**
    RMSE: {metrics[best_model]['RMSE']:.2f}
    MAPE: {metrics[best_model]['MAPE']:.2f}%

 **ПРОГНОЗ НА 30 ДНЕЙ:**
    Текущая цена: ${current_price:.2f}
    Прогноз через 30 дней: ${forecast_end_price:.2f}
    Изменение: ${price_change:.2f} ({pct_change:.2f}%)
    Ожидаемый тренд: {'РОСТ' if pct_change > 0 else 'ПАДЕНИЕ' if pct_change < 0 else 'СТАБИЛЬНО'}

 **КРАТКОСРОЧНЫЙ ПРОГНОЗ (первые 7 дней):**
"""

        # Добавляем прогноз на первые 7 дней
        for i in range(min(7, len(forecast))):
            day_price = forecast.iloc[i]
            day_change = ((day_price - current_price) / current_price) * 100
            report += f"   {forecast.index[i].strftime('%d.%m')}: ${day_price:.2f} ({day_change:+.2f}%)\n"

        # Добавляем отчет о прибыли
        report += f"\n{profit_report}"

        # Добавляем рекомендации по управлению рисками
        if pct_change > 10:
            report += "\n **ВЫСОКИЙ ПОТЕНЦИАЛ РОСТА** - Рассмотрите увеличение позиции"
        elif pct_change < -5:
            report += "\n **ПОТЕНЦИАЛЬНЫЙ РИСК** - Рассмотрите стоп-лосс ордера"
        else:
            report += "\n **УМЕРЕННЫЙ РИСК** - Диверсифицируйте портфель"

        #report += f"\n\n График сохранен в файле"

        logger.info(f"Анализ {ticker} завершен успешно")

        # Возвращаем результаты
        return {
            'success': True,
            'ticker': ticker,
            'current_price': current_price,
            'forecast_end_price': forecast_end_price,
            'pct_change': pct_change,
            'best_model': best_model,
            'metrics': metrics[best_model],
            'plot_path': plot_filename,
            'forecast': forecast,
            'report': report
        }

    except Exception as e:
        error_msg = f"Ошибка анализа: {str(e)}"
        logger.error(error_msg)
        return {'success': False, 'error': error_msg}

# --- Telegram Bot ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик команды /start"""
    welcome_text = """
 *Добро пожаловать в @topcallerstock_bot!*

Я помогу вам проанализировать акции, сделать прогноз, дать рекоммендации.

 *Доступные команды:*
/start - Показать это сообщение
/analyze <тикер> <сумма> - Проанализировать акции
  Пример: `/analyze AAPL 1000`
  Пример: `/analyze TSLA 5000`

 *Примеры тикеров:*
  AAPL - Apple
  TSLA - Tesla
  MSFT - Microsoft
  GOOGL - Alphabet (Google)
  AMZN - Amazon


"""
    await update.message.reply_text(welcome_text, parse_mode='Markdown')

async def analyze_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик команды /analyze"""
    try:
        if not context.args:
            await update.message.reply_text(
                "Пожалуйста, укажите тикер акции.\n"
                "Пример: `/analyze AAPL 1000`",
                parse_mode='Markdown'
            )
            return

        ticker = context.args[0].upper()
        investment = float(context.args[1]) if len(context.args) > 1 else 1000
        user_id = update.effective_user.id
        if investment <= 0:
            await update.message.reply_text("Сумма инвестиций должна быть больше 0")
            return

        # Отправляем сообщение о начале анализа
        status_message = await update.message.reply_text(
            f"*Начинаю анализ {ticker}...*\n"
            f"Сумма инвестиций: ${investment:,.2f}\n"
            "Это займет около 1-2 минут...",
            parse_mode='Markdown'
        )

        # Выполняем анализ
        result = analyze_stock(ticker, investment)

        # Отправляем результат
        if result['success']:
            log_user_request(
                user_id=user_id,
                ticker=ticker,
                investment=investment,
                best_model=result['best_model'],
                metric_rmse=result['metrics']['RMSE'],
                profit_pct=result['pct_change']
            )
            # Отправляем текстовый отчет
            await update.message.reply_text(
                result['report'],
                parse_mode='Markdown'
            )

            # Отправляем график
            try:
                with open(result['plot_path'], 'rb') as photo:
                    await update.message.reply_photo(
                        photo=photo,
                        caption=f"График прогноза для {ticker}\n"
                                f"Дата анализа: {datetime.now().strftime('%d.%m.%Y %H:%M')}"
                    )
                # Удаляем временный файл
                os.remove(result['plot_path'])
            except Exception as e:
                logger.error(f"Ошибка при отправке графика: {e}")
                await update.message.reply_text(
                    "Не удалось отправить график, но текстовый отчет готов."
                )

            # Удаляем сообщение о статусе
            await status_message.delete()

        else:
            await update.message.reply_text(
                f"*Ошибка анализа:*\n{result['error']}",
                parse_mode='Markdown'
            )

    except ValueError as e:
        await update.message.reply_text(
            "*Ошибка в формате команды.*\n"
            "Правильный формат: `/analyze AAPL 1000`\n"
            "где AAPL - тикер, 1000 - сумма инвестиций",
            parse_mode='Markdown'
        )
    except Exception as e:
        logger.error(f"Ошибка в обработчике analyze_command: {e}")
        await update.message.reply_text(
            "*Произошла непредвиденная ошибка.*\n"
            "Попробуйте позже или проверьте корректность введенных данных.",
            parse_mode='Markdown'
        )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик команды /help"""
    help_text = """
*Помощь по использованию бота*

*Основные команды:*
/start - Начало работы с ботом
/analyze <тикер> [сумма] - Анализ акций
/help - Эта справка

*Как работает анализ:*
1. Загружаются исторические данные (2 года)
2. Обучаются 3 модели: Ridge, ARIMA, LSTM
3. Выбирается лучшая модель по точности
4. Строится прогноз на 30 дней
5. Формируются торговые рекомендации

*Важная информация:*
 Это образовательный инструмент
 Прогнозы не являются финансовой рекомендацией
"""
    await update.message.reply_text(help_text, parse_mode='Markdown')

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик ошибок"""
    logger.error(f"Ошибка при обработке обновления: {context.error}")
    if update and update.message:
        await update.message.reply_text(
            "Произошла ошибка при обработке вашего запроса. "
            "Попробуйте еще раз или обратитесь к разработчику."
        )

def main() -> None:

    """Основная функция запуска бота"""
    # Проверяем токен бота
    if not Config.BOT_TOKEN:
        print("ОШИБКА: BOT_TOKEN не найден в .env!")
        print("Создайте файл .env с BOT_TOKEN=ваш_токен")
        return
    # Создаем приложение
    application = Application.builder().token(Config.BOT_TOKEN).build()

    # Регистрируем обработчики команд
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("analyze", analyze_command))
    application.add_handler(CommandHandler("help", help_command))

    # Регистрируем обработчик ошибок
    application.add_error_handler(error_handler)

    # Запускаем бота
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()